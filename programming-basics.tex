%! TeX root = main.tex

\chapter{Programming Basics}

The C++ code for the Arduino has the same basic elements as those of any programming language. 
The code consists of a series of \emph{statements} that are translated (compiled) into instructions for the processor to execute.
Statements can contain \emph{expressions}, which are logical or mathematical \emph{operations} performed on memory \emph{variables} or constants.
The \emph{flow} of the program, or which instructions are executed and whether they are repeated, can be controlled to implement complex functionality.

When working in teams and making large projects, the program source code can become hard to follow and understand.
to reduce complexity and simplify program development, some abstractions can be introduced to better organize the code.
Code that is reused multiple times can be made into \emph{functions}.
Variables that exist together can be grouped into \emph{structures} and \emph{classes} can be used to tie structures and functions together in hierarchical patterns.

In this chapter, we will go over the basic concepts highlighted above and how they are implemented in the C and C++ languages, on the Arduino platform.

\section{Variables}
\label{sec:variables}
Data in the microcontroller's memory is organized as \keywd{variables} in C++ code.
In C and C++, each variable must be declared before it is used.
The declaration tells the compiler what is the variable type, its name, and optionally its initial value.

As an example, \inocodei{int x;} declares an integer variable named ``x''.
Variables are often declared with an initial value, like in the code \inocodei{float foo = 1.5;} which declares a floating-point (number with decimal part) variable named ``foo'' with initial value \num{1.5}.
Multiple variables of the same type can be declared together, like in the code \inocodei{int a,b,c;} which declared three variables, named ``a'', ``b'', and ``c'', of integer type.
Variable declarations, as other \keywd{statements} in C++, must end in a semicolon.

\subsection{Identifiers}
The name of a variable is formally called its \keywd{identifier} in C and C++.
An identifier in C++ must obey the following simple rules:

\begin{enumerate}
  \item 
  The first character is a letter or an underscore (\texttt{\_}).
  Digits are not allowed in the first position.
  \item 
  The remaining characters may be letters, digits or underscores.
  No spaces, hyphens or other symbols are allowed.
  \item 
  Identifiers are case-sensitive, so \inocodei{motor}, \inocodei{Motor} and \inocodei{MOTOR} identify three different variables.
  \item 
  The identifier cannot match a reserved keyword such as \inocodei{int}, \inocodei{for}, or \inocodei{while}, for example.
\end{enumerate}

Examples of valid identifiers are \inocodei{button1_state}, \inocodei{_vel}, while \inocodei{1button}, \inocodei{error!} and \inocodei{time-frame} cannot be used as identifiers.
To write good code, please choose informative variable identifiers.
This is a skill that is developed over time, but perfer identifiers that capture purpose: \inocodei{ambientTemperatureC} or \inocodei{motorSpeedRPM} say far more than generic placeholders like \inocodei{temp}, \inocodei{var}, or \inocodei{temporary}.
Descriptive names double as in-line documentation, speeding reviews and maintenance, and they appear at the top of virtually every modern programming style guide.

\subsection{Types}
The C and C++ languages are strongly typed, meaning that a variable is declared with a specific type that cannot change throughout its lifetime.
For example, if a variable is declared as an integer (\inocodei{int}) it cannot hold a value with a fractional part.
When a floating-point value is assigned to an integer variable, the fractional part is truncated before assignment---that is, the number is rounded toward zero.
The fundamental built-in types of C++ can be divided into four broad families:
\begin{description}
\item[Integers:] whole numbers without a fractional part. They come in signed and unsigned varieties and four standard widths.
\item[Floating-point numbers:] real numbers that can carry a fractional component.
\item[Boolean:] a logic variable that takes values true or false.
\item[Characters:] byte-size numbers that are designed for text but are equally handy for raw bytes, bit-masks, and small lookup tables.
\item[Pointers:] a number that represents a location in the processor's memory.
\item[Void:] the \emph{no-type} type. It represents the absence of a value, like in a function that does not return anything.
\end{description}

\begin{table}[b]
  \caption{%
    Fundamental types in C++ and their width in the AVR architecture   (Arduino Uno Rev3), ARM (Raspberry Pi Pico 2 or Arduino Due), and the minimum requirements of the C++ standard.
    The rightmost column gives the minumum range of values a variable of this type should be able to represent, according to the standard.
  }
  \label{tab:cpp-fundamental}
  \pgfplotstabletypeset[
      col sep=&, row sep=\\, string type,
      columns/Keyword/.style={column type={>{\ttfamily}r}},
      every head row/.style={
        output empty row,              % ‚Üê suppress automatic header
        before row={
          \toprule
          % first custom header line
          \multicolumn{1}{c}{} % empty cell over Keyword
          &\multicolumn{3}{c}{\emph{Number of bits}}  % merged over three cols
          &\multicolumn{1}{c}{} % empty cell
          \\
          \cmidrule(lr){2-4}
          % second header line (per-column labels)
          \textrm{\textbf{Keyword}} & AVR & ARM & Min. &
          \textbf{Min. Range} \\
          \midrule
        },
        after row={},
      }
    ]{%
    Keyword & BitsAVR & BitsARM & MinBits& Min. Range\\
    bool & 8 & 8 & --- & 0 (false) or 1 (true) \\
    signed char& 8 & 8 & 8 & \num{-128} to \num{127} \\
    unsigned char& 8 & 8 & 8 & \num{0} to \num{255} \\
    signed short int& 16 & 16 & 16 & \num{-32768} to \num{32767} \\
    unsigned short int& 16 & 16 & 16 & \num{0} to \num{65535} \\
    signed int& 16 & 32 & 16 & \num{-32768} to \num{32767} \\
    unsigned int& 16 & 32 & 16 & \num{0} to \num{65535} \\
    signed long int& 32 & 32 & 32 & \num{+-2.1e9} \\
    unsigned long int& 32 & 32 & 32 & \num{0} to \num{4.3e9} \\
    signed long long int& 64 & 64 & 64 & \num{+-9.2e18} \\
    unsigned long long int& 64 & 64 & 64 & \num{0} to \num{1.8e19} \\
    float & 32 & 32 & 32 & \num{+-3.4e38} \\
    double & 32 & 64 & 64 & \num{+-1.8e308} \\
  }  
\end{table}

A variable's type also determines how much memory is required to store it and, consequently, the range of values it can represent.
A summary of the size of some fundamental types and the minimum range they can represent is shown in Table~\ref{tab:cpp-fundamental}, along with their standard width in some processor architectures that are used with the Arduino platform.
The keywords \inocodei{short}, \inocodei{long}, and \inocodei{long long} are modifiers that ask the compiler for progressively wider integers, while \inocodei{signed} and \inocodei{unsigned} include or remove the sign bit which can half or double the positive range of a number. 
The C++ standard specifies only minimum widths, so the exact size depends on the tools and configuration used.
Note that not all compilers comply fully with the standard---the compiler of the AVR architecture for the Arduino Uno Rev3, for example, uses only 32 bits to store a \texttt{double}, less than the minimum 64 bits required by the standard.

The type specifiers shown in Table~\ref{tab:cpp-fundamental} are quite long, however.
The C++ language accepts shorthands which are often used in code.
The specifiers \inocodei{int} and \inocodei{signed} can be ommited when used with other specifiers.
A summary of common equivalent specifiers is shown in Table~\ref{tab:type-specifiers-shorthand}.

\begin{table}
  \centering
  \caption{Examples of equivalent type specifiers in C++.}
  \label{tab:type-specifiers-shorthand}
  \pgfplotstabletypeset[
    col sep=&, row sep=\\, string type,
  ]{%
    Common shorthand & Long form \\
    \texttt{int} & \texttt{signed int} \\
    \texttt{long} & \texttt{signed long int} \\
    \texttt{unsigned} & \texttt{unsigned int} \\
    \texttt{unsigned long int} & \texttt{unsigned long} \\
  }  
\end{table}

The standard C/C++ libraries also specify integers with an \emph{exact} number of bits to help write platform-independent code.
This is especially important when writing software libraries.
The specifiers \inocodei{int8_t}, \inocodei{int16_t}, \inocodei{int32_t}, and \inocodei{int64_t} stand for signed integers of exactly \num{8}, \num{16}, \num{32}, and \num{64} bits, respectively, while \inocodei{uint8_t}, \inocodei{uint16_t}, \inocodei{uint32_t}, and \inocodei{uint64_t} represent the equivalent unsigned integers.

% The paragraph below was written mostly by chatgpt.
% https://chatgpt.com/share/6862a592-7ab0-8012-8d13-9f8228d3c536
In addition to type and scope, C++ also allows you to further qualify variables with the keywords \inocodei{const} and \inocodei{constexpr}. 
The \inocodei{const} keyword marks a variable as read-only---it must be assigned once, and any further attempt to change its value will result in a compile-time error.
The \inocodei{constexpr} keyword goes a step further: it requires the value to be known at compile time. 
On microcontrollers, this means the variable will not occupy RAM, since its value is embedded directly into the program code stored in flash memory. 
This is especially important for values like pin numbers, array sizes, or fixed configuration constants in resource-constrained systems.

\subsection{Scopes}
When projects grow, there arises a need to reuse variable names in different contexts.
When authoring a function or a code fragment, development is also simplified if the new code added won't have unintended consequences elsewhere.
The concept of \keywd{scopes} helps us organize that.

At the top level, there is the \keywd{global scope}%
\footnote{%
  In the C standard, the global scope is officially called \keywd{file scope} while in the C++ standard it is the \keywd{global namespace scope}, but they are essentially the same. \cneed
}, which has variables that can be accessed throughout the whole program.
Whether to make a variable global or not is a programming choice
Simple, short programs often use global variables.
In larger codebases, however, global variables can make the code difficult to understand and debug because \emph{any} line of code can use or alter them.
To reduce the cognitive load on the programmer, it is helpful to restrict variables to smaller chunks of code called \keywd{blocks}.

Blocks are sections of code between curly brackets \texttt{\{\}}.
In the example code \texttt{Scopes.ino}, shown below, there are two blocks, the \texttt{setup} and \texttt{loop} functions.
Variables declared in a block scope exist in the computer memory during the execution of the lines of code between the variable declaration and the end of the block.
Variables declared outside any block are global.
In the \texttt{Scopes.ino} program, the variable \texttt{foo} is global while \texttt{bar} is local to the \texttt{loop} function block.
Note that the global variable \texttt{foo} can be accessed (written to and read) inside any block of code.

\inofile{Scopes.ino}

A variable cannot be declared more than once within a scope using the same identifier.
Different variables with the same identifier can be declared in different scopes, however.
When multiple variables with the same identifier are declared in different scopes, only the one in the innermost scope will be accessed.
In this case, we say that the variables in the outer scopes are \emph{shadowed} by the local one.

Blocks can be created inside blocks, like shown in the example program \texttt{NestedScopes.ino}.
A new block, inside the block of the \texttt{setup} function, starts at line 5 and ends at line 7.
The variable \texttt{foo} declared at line 6 shadows the global variable \texttt{foo} declared at line 1.
Note that the new variable can be of any type; in this example its type is different from the one in the outer scope.
Nested blocks are usually associated with control flow statements such as if/else, for, or while.

\inofile{NestedScopes.ino}

\section{Operators and Expressions}
The basic mathematical and logic operations on variables are performed with \keywd{operators} like addition, multiplication, division, and so on.
One or more operators form an expression that has yields a value that can be used for program flow control or be assigned to another variable.

Like in standard math notation, some operators have \emph{precedence} with respect to others.
Higher precedence operators, like multiplication, are evaluated before lower precedence ones, like addition.
Table~\ref{tab:operators} lists common operators in the C and C++ languages sorted by order of precedence.
A pair of matching parentheses \texttt{()} can be used to group expressions in order to change the order of evaluation%
\footnote{%
  In my years as an instructor, I've seen students add a baffling number of parentheses, around every operator, to make sure the expression is calculated in the order they want.
  They usually do this because they are unsure about the order of precedence and there is a bug---usually unrelated to the expressions being changed---whose root they cannot find.
  While this has no effect on the program behavior, it makes the code harder to read, so try to avoid it.
  When in doubt, a quick internet search for ``C/C++ operator precedence'' will give multiple results for reference.
}.
If two operators have the same precedence, like addition and subtraction, the expression is evaluated from left to right.

\begin{table}
  \centering
  \caption{Common operators in C and C++, groups from higher to lower precedence order.}
  \label{tab:operators}
  \small
  \begin{tabular}{lp{6cm}l}
    \textbf{Operator} & \textbf{Description} & \textbf{Example} \\
    \hline\hline
    \multicolumn{3}{c}{\emph{Precedence: primary}} \\
    \inocodei{[]} & Array subscripting. & \inocodei{a[i]} \\
    \inocodei{()} & Function call.      & \inocodei{f(x)} \\
    \inocodei{.}  & Member access.      & \inocodei{o.m}  \\
    \inocodei{++} & Increment.     & \inocodei{i++}  \\
    \inocodei{--} & Decrement.     & \inocodei{i--}  \\
    \hline
    \multicolumn{3}{c}{\emph{Precedence: unary}} \\
    \inocodei{-}  & Unary minus. & \inocodei{-i}  \\
    \inocodei{!}  & Logical NOT. & \inocodei{!a}  \\
    \inocodei{~}  & Bitwise NOT. & \inocodei{~a}  \\
    \hline
    \multicolumn{3}{c}{\emph{Precedence: multiplicative}} \\
    \inocodei{*} & Multiplication.                  & \inocodei{a * b} \\
    \inocodei{/} & Division.                        & \inocodei{a / b} \\
    \inocodei{%} & Remainder of division (modulus). & \inocodei{a % b} \\
    \hline
    \multicolumn{3}{c}{\emph{Precedence: additive}} \\
    \inocodei{+} & Addition.    & \inocodei{a + b}       \\
    \inocodei{-} & Subtraction. & \inocodei{a - b}       \\
    \hline
    \multicolumn{3}{c}{\emph{Precedence: relational}} \\
    \inocodei{<}  & Less than.              & \inocodei{a < b}       \\
    \inocodei{<=} & Less than or equal.     & \inocodei{a <= b}      \\
    \inocodei{>}  & Greater than.           & \inocodei{a > b}       \\
    \inocodei{>=} & Greater than or equal.  & \inocodei{a >= b}      \\
    \hline
    \multicolumn{3}{c}{\emph{Precedence: equality}}  \\
    \inocodei{==} & Equality.    & \inocodei{a == b} \\
    \inocodei{!=} & Inequality.  & \inocodei{a != b} \\
    \hline
    \multicolumn{3}{c}{\emph{Precedence: bitwise AND}} \\
    \inocodei{&} & Bitwise and. & \inocodei{a & b}      \\
    \hline
    \multicolumn{3}{c}{\emph{Precedence: bitwise XOR}} \\
    \inocodei{^} & Bitwise exclusive or (XOR). & \inocodei{a ^ b} \\
    \hline
    \multicolumn{3}{c}{\emph{Precedence: bitwise OR}} \\
    \inocodei{|}  & Bitwise or. & \inocodei{a | b}    \\
    \hline
    \multicolumn{3}{c}{\emph{Precedence: logical AND}} \\
    \inocodei{&&} & Logical and. & \inocodei{a && b}   \\
    \hline
    \multicolumn{3}{c}{\emph{Precedence: logical OR}} \\
    \inocodei{||} & Logical or. & \inocodei{a || b}   \\
    \hline
    \multicolumn{3}{c}{\emph{Precedence: assignment}} \\
    \inocodei{=}  & Simple assignment.   & \inocodei{x = y}  \\
    \inocodei{+=} & Add and assign.      & \inocodei{x += y} \\
    \inocodei{-=} & Subtract and assign. & \inocodei{x -= y} \\
  \end{tabular}
\end{table}

Most of the operators and their binding rules for C and C++ are the same as in other programming languages like MATLAB or Python.
Some important operators in C and C++ and common errors associated to their use are listed below.

Assignment corresponds to saving the value of a variable or expression into a variable.
A single equal sign \texttt{=} is the assignment operator, and assigns the expression on the right of the sign to the variable or memory location on the left.
For example, to assign the mathematical expression $2y + 1$ to the variable \texttt{x} we use the expression \inocodei{x = 2*y + 1}.

Equality testing is done with double equal signs \texttt{==} and will evaluate to \texttt{true} only when the expressions on both sides of the operator are equal.
Equality and assignment are commonly mixed-up by beginner programmers since their operators are so similar.
Note that the C and C++ languages accept assignments in if and while clauses, so sometimes a program with assignment inadvertently used in place of equality tests will compile but fail silently, without the intended behavior.

Incrementing variables is such a common operation that C and C++ have a special operator for it, coded with double equal signs \texttt{++}.
The expression \inocodei{x = x + 1}, which increases the value of the variable \texttt{x} by one, is equivalent to the more succint expression \inocodei{x++}.
The name of the C++ language comes from this operator, it was created as a next version of C, or increased by one.

Another shorthand class of operators are the compound assignment operators, such as \texttt{+=} and \texttt{-=}.
The expression \inocodei{x += 5} is equivalent to \inocodei{x = x + 5} and \inocodei{y -= 2} is equivalent to \inocodei{y = y - 2}.
These are commonly used in for loops when the loop variable is incremented by a factor different than one.

It is also important to know that exponentiation, the power operator $x^y$, is \emph{not} done with the hat sign \inocodei{x ^ y}, as in MATLAB.
Instead, in C and C++, the hat sign \inocodei{x ^ y} is the exclusive or (XOR) Boolean operator.
Exponentiation in Arduino code is done with the \inocodei{pow(x, y)} function.

Finally, there are two types of Boolean operators in C and C++: bitwise and logical.
Bitwise operators perform the logical operation on each individual bit of the variables and are often used in low-level memory register configuration and implementation of hardware drivers.
Logical operations are the ones used when testing multiple conditions.
Any numerical value is a logical false when it is equal to zero and a logical true if it is nonzero.
That way, the expression \inocodei{2 & 1} evaluates to false while \inocodei{2 && 1} evaluates to true.
When writing logical expressions, logical operators are recommended.

\section{Statements}
In C and C++, \keywd{statements} are a fundamental unit of code that expresses an action to be performed \cite[cl.~6.8]{C23}.
The most basic type of statement is an expression followed by a semicolon, such as \inocodei{x = 42;} which assigns the value 42 to the previously declared variable \texttt{x}.
Any expression terminated by a semicolon is a stament, and the semicolon acts a statement separator symbol.
Note that an empty expression followed by a semicolon is a null statement \cite[cl.~6.8.3]{C23}, which expresses that no operation should be performed.

A \keywd{block}, a section of code between curly brackets \texttt{\{\}}, is also a statement.
Blocks have their own scope, as mentioned in Sec.~\ref{sec:variables}, and can also be composed of multiple statements.
They express complex actions that can be composed of multiple sub-actions.

Statements are important because program flow control structures such as \texttt{if}, \texttt{else}, \texttt{for}, and \texttt{while} control whether and how many times statements are executed.
Understanding how statements are grouped and separated is important to follow the program flow logic of a piece of code.

Finally, program flow control structures themselves, detailed in the following section, are statements as well.

\section{Flow Control}
\subsection{Selection Statements}
Conditional execution of statements is an indispensable feature of any programming language.
In C and C++, this is done with the if and if-else statements.
As an example, the code \inocodei{if (x == 3) y = 2;} tests if the variable \texttt{x} is equal to three, and if it is the value 2 is assigned to the variable \texttt{y}.
In the example above, if \texttt{x} is not equal to three, the assignment is not executed and the program continues after the semicolon.
In C and C++, an expression is true when it is nonzero and false otherwise.

The longer example below describes the structure of an \keywd{if statement} in more detail.
It begins with the keyword \texttt{if}, followed by a pair of matching parenthesis \texttt{()} with a controlling expression inside.
This \emph{controlling expression} determines whether the statement following the parenthesis, the \emph{conditional statement}, will be executed or not.
The conditional expression cannot be of type \texttt{void}, which represents an empty expression.
The first statement following the parenthesis will then be executed whenever the expression is true.
In the example below, for example, the text ``Foo!'' will be printed to the serial port if the numerical expression $2x + 1$ is equal to 4.
Program flow then resumes with the next statement, which is the \SI{1000}{ms} delay that will be executed regardless of the controlling expression.

\begin{inocode}
if (2*x + y == 4)        // Keyword and expression
  Serial.println("Foo!"); // Statement when true.

// Normal program flow resumes after the statement
// following the paranthesis.
delay(1000);
\end{inocode}

A longer sequence of statements can be conditionally executed by using a block as the conditional statement, like in the more involved example below.
If executed as is, the text ``$2x + y$ equals 4, since $x=3$ and $y=-2$'' will be printed in the first line, since the conditional expression is true.
This is done using multiple statements inside the block.

\inofile{IfExample.ino}

A common error when coding the if statement is forgetting the parenthesis around the expression.
Python and MATLAB, in particular, don't require a parenthesis around the expression and students switching between these languages and C or C++ can mix-up their syntax.

Incorrect placement of the semicolon is also fairly common.
Again, some languages do not require semicolons, so when switching to C and C++, some students forget them, while others add too many.
A particularly hard problem to debug is when a semicolon is placed right after the parenthesis of the if, like in the code \inocodei{if (x == 3); y = 2;}
When the \texttt{x} equals three, the \emph{null statement}---that is, no action---is executed, and then value 2 is always assigned to \texttt{y}.
While this code is \emph{synctactically} correct, since it compiles and runs on the processor, it is usually \emph{semantically} incorrect, as it is seldomly what is intended by the programmer.

Another statement can be executed when the controlling expression is false by adding an \emph{else} clause.
This is done by following the conditional statement with the \texttt{else} keyword and another statement, the \emph{else conditional statement}.
Once again, this statement can be a single expression followed by a semicolon or a block statement with multiple statements.
An example of the if-else statement is shown in the code listing \texttt{IfElseExample.ino} below.

\inofile{IfElseExample.ino}

Note that if and if-else are also, themselves, statements.
Everything from the \texttt{if} keyword to the conditional statements is a single statement.
This allows if statements to be used inside other program flow control structures---even other if statements.

\subsection{Iteration Statements}
Repeating a statement multiple times is another indispensable feature of any programming language.
In C and C++, this is done with the for and while statements.

The \keywd{while statement} consists of the \texttt{while} keyword, followed by a parenthesis with a conditional expression inside and a \emph{loop body} statement afterwards.
When program flow reaches the \texttt{while} keyword, the expression is evaluated and, if it is true, the loop body is executed.
After that, the expression is re-evaluated and the whole process starts over.
The loop body is repeated multiple times until the controlling expression evaluates to false.

The example program \texttt{WhileExample.ino}, below, illustrates the use of the while statement.
After an integer counter \texttt{i} is initialized to one, it is printed and incremented multiple times until it is no longer less than or equal to ten.

\inofile{WhileExample.ino}

The specific example above can also be written, more succintly, using a \emph{for statement}, as shown in the example program \texttt{ForExample.ino}.
In C and C++, the for loop has the format \inocodei{for (init; condition; increment) loop_body} where \texttt{init} is an initialization expression or variable declaration that is done before starting the loop, \texttt{condition} is a controlling expression that determines if the looping should be continued, and \texttt{increment} is an expression that is executed at the end of each iteration, before the condition is tested again.
The \texttt{loop\_body} is a statement, such as block.

\inofile{ForExample.ino}

The use of the for loop usually signals to others reading the code that a statement is run with a variable taking a range of values.
Although the same logic can be implemented with a while loop, the use of the for loop makes the code more readable.
In the example \texttt{ForExample.ino}, the numbers 1 to 10 are printed on the serial port, just like in \texttt{WhileExample.ino}.

\section{Functions}
Functions are pieces of code that can be reused throughout the program.
The main reason for using functions is that, when done right, it simplifies program development, testing, and debugging.
Rewriting the same code section at multiple points in the program opens up the possibility of introducing errors in one of the copies.
Conversely, if there is an error in the logic, it has to be fixed at multiple points instead of at a single function.
A program with functions with descriptive names is simpler to understand than one with many equivalent sections of code.
Testing also becomes simpler and modular, as each function implements simpler behaviors whose correctness is easier to test than that of the whole program.

Creating functions in C and C++ follows the same syntax as the \texttt{setup} and \texttt{loop} functions, like shown in the example program \texttt{FunctionExample.ino}.
Like a variable declaration, the function definition starts with the function return type, followed by its identifier, a list of input arguments inside parenthesis, and a block with the function body.
If the function return type is not void, then it must have a line with a \texttt{return} statement, which indicates the value the function will return as its output.

\clearpage
\inofile{FunctionExample.ino}
\inofile{ToggleLED.ino}

Functions are called by their identifier followed by their arguments inside a pair of matching parentheses \texttt{()}, like in lines 2, 6, 10, and 11 of the example program \texttt{ToggleLED.ino}.
Multiple arguments are separated by commas, inside the parentheses, like in lines 2 and 6.
Calling a function is an operator in C and C++, so it can be used inside expressions.
The function return value is the result of a function call operator.
The built-in LED of Arduino boards is toggled in line 2 of the example program
It does so by calling the \texttt{digitalRead} function, which returns the current state of the pin (1 or 0), inverts it with the \texttt{!} operator, and gives it as the second argument of the \texttt{digitalWrite} function, which sets the value of the pin.
This way, if the LED is on (\texttt{digitalRead} returns 1), it will be turned off.
Conversely, if the LED is off (\texttt{digitalRead} returns 0), it will be turned on.

In C and C++, a function must be declared before it is called, so their definition is usually at the top of the file, before the main program logic.
A \texttt{return} statement indicates not only the function output value, but that the program flow \emph{returns} execution to where the function call was made.
This is why void functions can have \inocodei{return;} statements without a value before the semicolon, meaning that the function execution should end there.

\section{Structures}
Just like functions group together related a sequence of statements, we often need to group related data together in the code.
This can be achieved by using structures, which are custom data types that allow us to combine multiple variables under a single name.

\begin{figure}[b]
  \centering
  \includegraphics[width=0.5\textwidth]{img/hc-sr04.jpg}
  \\ \scriptsize
  Source: \href{https://www.sparkfun.com/ultrasonic-distance-sensor-hc-sr04.html}{SparkFun electronics}.
  \caption{HC-SR04 ultrasonic distance sensor.}
  \label{fig:hc-sr04}
\end{figure}

Consider, for example, an HC-SR04 ultrasonic distance sensor, like the one shown in Fig.~\ref{fig:hc-sr04}.
This sensor measures the distance to an object with the time it takes for a burst of ultrasound emitted by the sensor to be reflected back.
It is controlled by the Arduino using two digital pins, one that the microcontroller uses to trigger the burst to be emitted and another used by the sensor to signal that the echo has arrived.
These pins are labelled \emph{Trig} and \emph{Echo}, respectively.

Arduino rovers often have multiple ultrasonic sensors, for obstacle avoidance.
In this case, it is useful to group the pins of each sensor in a single variable to make the code more compact.
This can be accomplished with a \texttt{struct}, like shown in the program \texttt{UltrasonicStruct.ino}.
The program starts with the definition of an ultrasonic struct.

\clearpage
\inofile{UltrasonicStruct.ino}
\section{Classes and Objects}


%%% Local Variables:
%%% TeX-master: "main"
%%% eval: (adaptive-wrap-prefix-mode t)
%%% eval: (visual-line-mode t)
%%% eval: (nlinum-mode t)
%%% TeX-engine: luatex
%%% End: