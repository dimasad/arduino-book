%! TeX root = main.tex

\chapter{Programming Basics}

The C++ code for the Arduino has the same basic elements as those of any programming language. 
The code consists of a series of \emph{statements} that are translated (compiled) into instructions for the processor to execute.
Statements can contain \emph{expressions}, which are logical or mathematical \emph{operations} performed on memory \emph{variables} or constants.
The \emph{flow} of the program, or which instructions are executed and whether they are repeated, can be controlled to implement complex functionality.

When working in teams and making large projects, the program source code can become hard to follow and understand.
to reduce complexity and simplify program development, some abstractions can be introduced to better organize the code.
Code that is reused multiple times can be made into \emph{functions}.
Variables that exist together can be grouped into \emph{structures} and \emph{classes} can be used to tie structures and functions together in hierarchical patterns.

In this chapter, we will go over the basic concepts highlighted above and how they are implemented in the C++ language, on the Arduino platform.

\section{Variables and Scopes}
Data in the microcontroller's memory is organized as \emph{variables} in C++ code.
In C and C++, each variable must be declared before it is used.
The declaration tells the compiler what is the variable type, its name, and optionally its initial value.

As an example, \inocodei{int x;} declares an integer variable named ``x''.
Variables are often declared with an initial value, like in the code \inocodei{float foo = 1.5;} which declares a floating-point (number with decimal part) variable named ``foo'' with initial value \num{1.5}.
Multiple variables of the same type can be declared together, like in the code \inocodei{int a,b,c;} which declared three variables, named ``a'', ``b'', and ``c'', of integer type.
Variable declarations, as other \emph{statements} in C++, must end in a semicolon.

\subsection{Identifiers}
The name of a variable is formally called its \emph{identifier} in C and C++.
An identifier in C++ must obey the following simple rules:

\begin{enumerate}
  \item 
  The first character is a letter or an underscore (\texttt{\_}).
  Digits are not allowed in the first position.
  \item 
  The remaining characters may be letters, digits or underscores.
  No spaces, hyphens or other symbols are allowed.
  \item 
  Identifiers are case-sensitive, so \inocodei{motor}, \inocodei{Motor} and \inocodei{MOTOR} identify three different variables.
  \item 
  The identifier cannot match a reserved keyword such as \inocodei{int}, \inocodei{for}, or \inocodei{while}, for example.
\end{enumerate}

Examples of valid identifiers are \inocodei{button1_state}, \inocodei{_vel}, while \inocodei{1button}, \inocodei{error!} and \inocodei{time-frame} cannot be used as identifiers.
To write good code, please choose informative variable identifiers.
This is a skill that is developed over time, but perfer identifiers that capture purpose: \inocodei{ambientTemperatureC} or \inocodei{motorSpeedRPM} say far more than generic placeholders like \inocodei{temp}, \inocodei{var}, or \inocodei{temporary}.
Descriptive names double as in-line documentation, speeding reviews and maintenance, and they appear at the top of virtually every modern programming style guide.

\subsection{Types}
The C and C++ languages are strongly typed, meaning that a variable is declared with a specific type that cannot change throughout its lifetime.
For example, if a variable is declared as an integer (\inocodei{int}) it cannot hold a value with a fractional part.
When a floating-point value is assigned to an integer variable, the fractional part is truncated before assignment---that is, the number is rounded toward zero.
The fundamental built-in types of C++ can be divided into four broad families:
\begin{description}
\item[Integers:] whole numbers without a fractional part. They come in signed and unsigned varieties and four standard widths.
\item[Floating-point numbers:] real numbers that can carry a fractional component.
\item[Boolean:] a logic variable that takes values true or false.
\item[Characters:] byte-size numbers that are designed for text but are equally handy for raw bytes, bit-masks, and small lookup tables.
\item[Pointers:] a number that represents a location in the processor's memory.
\item[Void:] the \emph{no-type} type. It represents the absence of a value, like in a function that does not return anything.
\end{description}

\begin{table}[b]
  \caption{%
    Fundamental types in C++ and their width in the AVR architecture   (Arduino Uno Rev3), ARM (Raspberry Pi Pico 2 or Arduino Due), and the minimum requirements of the C++ standard.
    The rightmost column gives the minumum range of values a variable of this type should be able to represent, according to the standard.
  }
  \label{tab:cpp-fundamental}
  \pgfplotstabletypeset[
      col sep=&, row sep=\\, string type,
      columns/Keyword/.style={column type={>{\ttfamily}r}},
      every head row/.style={
        output empty row,              % ‚Üê suppress automatic header
        before row={
          \toprule
          % first custom header line
          \multicolumn{1}{c}{} % empty cell over Keyword
          &\multicolumn{3}{c}{\textbf{Number of bits}}  % merged over three cols
          &\multicolumn{1}{c}{} % empty cell
          \\
          \cmidrule(lr){2-4}
          % second header line (per-column labels)
          \textrm{\textbf{Keyword}} & AVR & ARM & Min. &
          \textbf{Min. Range} \\
          \midrule
        },
        after row={},
      }
    ]{%
    Keyword & BitsAVR & BitsARM & MinBits& Min. Range\\
    bool & 8 & 8 & --- & 0 (false) or 1 (true) \\
    signed char& 8 & 8 & 8 & \num{-128} to \num{127} \\
    unsigned char& 8 & 8 & 8 & \num{0} to \num{255} \\
    signed short int& 16 & 16 & 16 & \num{-32768} to \num{32767} \\
    unsigned short int& 16 & 16 & 16 & \num{0} to \num{65535} \\
    signed int& 16 & 32 & 16 & \num{-32768} to \num{32767} \\
    unsigned int& 16 & 32 & 16 & \num{0} to \num{65535} \\
    signed long int& 32 & 32 & 32 & \num{+-2.1e9} \\
    unsigned long int& 32 & 32 & 32 & \num{0} to \num{4.3e9} \\
    signed long long int& 64 & 64 & 64 & \num{+-9.2e18} \\
    unsigned long long int& 64 & 64 & 64 & \num{0} to \num{1.8e19} \\
    float & 32 & 32 & 32 & \num{+-3.4e38} \\
    double & 32 & 64 & 64 & \num{+-1.8e308} \\
  }  
\end{table}

A variable's type also determines how much memory is required to store it and, consequently, the range of values it can represent.
A summary of the size of some fundamental types and the minimum range they can represent is shown in Table~\ref{tab:cpp-fundamental}, along with their standard width in some processor architectures that are used with the Arduino platform.
The keywords \inocodei{short}, \inocodei{long}, and \inocodei{long long} are modifiers that ask the compiler for progressively wider integers, while \inocodei{signed} and \inocodei{unsigned} include or remove the sign bit which can half or double the positive range of a number. 
The C++ standard specifies only minimum widths, so the exact size depends on the tools and configuration used.
Note that not all compilers comply fully with the standard---the compiler of the AVR architecture for the Arduino Uno Rev3, for example, uses only 32 bits to store a \texttt{double}, less than the minimum 64 bits required by the standard.

The type specifiers shown in Table~\ref{tab:cpp-fundamental} are quite long, however.
The C++ language accepts shorthands which are often used in code.
The specifiers \inocodei{int} and \inocodei{signed} can be ommited when used with other specifiers.
A summary of common equivalent specifiers is shown in Table~\ref{tab:type-specifiers-shorthand}.

\begin{table}
  \centering
  \caption{Examples of equivalent type specifiers in C++.}
  \label{tab:type-specifiers-shorthand}
  \pgfplotstabletypeset[
    col sep=&, row sep=\\, string type,
  ]{%
    Common shorthand & Long form \\
    \texttt{int} & \texttt{signed int} \\
    \texttt{long} & \texttt{signed long int} \\
    \texttt{unsigned} & \texttt{unsigned int} \\
    \texttt{unsigned long int} & \texttt{unsigned long} \\
  }  
\end{table}

The standard C/C++ libraries also specify integers with an \emph{exact} number of bits to help write platform-independent code.
This is especially important when writing software libraries.
The specifiers \inocodei{int8_t}, \inocodei{int16_t}, \inocodei{int32_t}, and \inocodei{int64_t} stand for signed integers of exactly \num{8}, \num{16}, \num{32}, and \num{64} bits, respectively, while \inocodei{uint8_t}, \inocodei{uint16_t}, \inocodei{uint32_t}, and \inocodei{uint64_t} represent the equivalent unsigned integers.

% The paragraph below was written mostly by chatgpt.
% https://chatgpt.com/share/6862a592-7ab0-8012-8d13-9f8228d3c536
In addition to type and scope, C++ also allows you to further qualify variables with the keywords \inocodei{const} and \inocodei{constexpr}. 
The \inocodei{const} keyword marks a variable as read-only---it must be assigned once, and any further attempt to change its value will result in a compile-time error.
The \inocodei{constexpr} keyword goes a step further: it requires the value to be known at compile time. 
On microcontrollers, this means the variable will not occupy RAM, since its value is embedded directly into the program code stored in flash memory. 
This is especially important for values like pin numbers, array sizes, or fixed configuration constants in resource-constrained systems.

\subsection{Scopes}
When projects grow, there arises a need to reuse variable names in different contexts.
When authoring a function or a code fragment, development is also simplified if the new code added won't have unintended consequences elsewhere.
The concept of \emph{scopes} helps us organize that.

At the top level, there is the \emph{global} scope%
\footnote{%
  In the C standard, the global scope is officially called \emph{file} scope while in the C++ standard it is the \emph{global namespace} scope, but they are essentially the same. \cneed
}, which has variables that can be accessed throughout the whole program.
Whether to make a variable global or not is a programming choice
Simple, short programs often use global variables.
In larger codebases, however, global variables can make the code difficult to understand and debug because \emph{any} line of code can use or alter them.
To reduce the cognitive load on the programmer, it is helpful to restrict variables to smaller chunks of code called \emph{blocks}.

\inofile{Scopes.ino}

\pending{}
Introduce blocks.
Variables declared outside of any block are global, like in line 1 of the example.
Variables declared inside a block can be accessed only inside the block, like in line 8 of the example.
A variable only exists in the block scope after it is declared, all the way until the block ends.

\pending{}
Blocks can be created inside blocks.
Give example of nested blocks.
Explain that they are mostly used in flow control statements.

Each line of code has multiple nested scopes that define where a variable can be accessed and its lifetime.
The most important scopes in C/C++ are the
\emph{global} scope, accessible on the whole program;
and the \emph{block} scope, accessible on the surrounding \texttt{\{\}} brackets, like the current function or loop.

\pending{Linkage can also change things with static and extern and how the compiler is invoked.}

\url{https://wokwi.com/projects/435374296218599425}
\url{https://wokwi.com/projects/435375265115543553}

\pending{A variable cannot be redeclared on the same scope.}

\section{Operators and Expressions}

\section{Statements}
\section{Operators}
\section{Flow Control}
\section{Functions}
\section{Structures}
\section{Classes}


%%% Local Variables:
%%% TeX-master: "main"
%%% eval: (adaptive-wrap-prefix-mode t)
%%% eval: (visual-line-mode t)
%%% eval: (nlinum-mode t)
%%% TeX-engine: luatex
%%% End: